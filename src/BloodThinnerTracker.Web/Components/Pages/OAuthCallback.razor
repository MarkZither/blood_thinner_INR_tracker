@page "/oauth-complete"
@rendermode InteractiveServer
@using Microsoft.AspNetCore.Authentication
@using Microsoft.AspNetCore.Components.Authorization
@using BloodThinnerTracker.Web.Services
@using BloodThinnerTracker.Shared.Models.Authentication
@using System.Net.Http.Json
@inject IHttpContextAccessor HttpContextAccessor
@inject CustomAuthenticationStateProvider AuthStateProvider
@inject NavigationManager Navigation
@inject ILogger<OAuthCallback> Logger
@inject HttpClient Http

<PageTitle>Signing in...</PageTitle>

<MudContainer MaxWidth="MaxWidth.Small" Class="mt-8">
    <MudPaper Elevation="2" Class="pa-6">
        @if (_isProcessing)
        {
            <MudStack Spacing="4" AlignItems="AlignItems.Center">
                <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Large" />
                <MudText Typo="Typo.h6">Completing sign-in...</MudText>
                <MudText Typo="Typo.body2" Color="Color.Secondary">Please wait while we authenticate you.</MudText>
            </MudStack>
        }
        else if (_error != null)
        {
            <MudAlert Severity="Severity.Error" Variant="Variant.Filled">
                <MudText Typo="Typo.h6">Sign-in Failed</MudText>
                <MudText Typo="Typo.body2" Class="mt-2">@_error</MudText>
                <MudButton Href="/login" Variant="Variant.Text" Color="Color.Default" Class="mt-4">
                    Try Again
                </MudButton>
            </MudAlert>
        }
    </MudPaper>
</MudContainer>

@code {
    private bool _isProcessing = true;
    private string? _error;
    private string? _accessToken;
    private string? _refreshToken;
    private string? _idToken;  // Store id_token for oid extraction
    private System.Security.Claims.ClaimsPrincipal? _authenticatedPrincipal;
    // Store a returnUrl restored from AuthenticationProperties.Items during initial authentication read
    private string? _restoredReturnFromProperties;

    [SupplyParameterFromQuery(Name = "provider")]
    public string? Provider { get; set; }

    [SupplyParameterFromQuery(Name = "returnUrl")]
    public string? ReturnUrl { get; set; }

    protected override async Task OnInitializedAsync()
    {
        try
        {
            Logger.LogInformation("OAuth complete page: Starting with provider {Provider}, returnUrl {ReturnUrl}",
                Provider ?? "unknown", ReturnUrl ?? "not provided");

            // Get HttpContext
            var httpContext = HttpContextAccessor.HttpContext;
            if (httpContext == null)
            {
                Logger.LogError("OAuth complete: HttpContext is null");
                _error = "Authentication service unavailable. Please try again.";
                _isProcessing = false;
                return;
            }

            // Get the authentication result from the cookie
            var authResult = await httpContext.AuthenticateAsync(Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationDefaults.AuthenticationScheme);

            if (!authResult.Succeeded)
            {
                Logger.LogWarning("OAuth complete: Cookie authentication not found");
                _error = "Sign-in failed. Please try again.";
                _isProcessing = false;
                return;
            }

            Logger.LogInformation("OAuth complete: Authentication succeeded, extracting tokens and claims...");

            // Extract tokens from authentication properties
            var tokens = authResult.Properties?.GetTokens();
            if (tokens == null || !tokens.Any())
            {
                Logger.LogError("OAuth complete: No tokens found in authentication properties");
                _error = "Authorization incomplete. Please sign in again.";
                _isProcessing = false;
                return;
            }

            // Log all available tokens for debugging
            foreach (var token in tokens)
            {
                Logger.LogInformation("OAuth complete: Token available - Name: {Name}, Length: {Length}",
                    token.Name, token.Value?.Length ?? 0);
            }

            var idToken = tokens.FirstOrDefault(t => t.Name == "id_token")?.Value;
            _idToken = idToken;  // Store for later use in OnAfterRenderAsync
            _accessToken = tokens.FirstOrDefault(t => t.Name == "access_token")?.Value;
            _refreshToken = tokens.FirstOrDefault(t => t.Name == "refresh_token")?.Value;

            if (string.IsNullOrEmpty(_accessToken))
            {
                Logger.LogError("OAuth complete: No access_token in authentication properties");
                _error = "Authorization incomplete. Please sign in again.";
                _isProcessing = false;
                return;
            }

            Logger.LogInformation("OAuth complete: access_token present, length: {Length}", _accessToken.Length);

            // Extract basic claims from the authenticated principal for display/logging
            var principal = authResult.Principal;
            if (principal?.Identity?.IsAuthenticated == true)
            {
                var email = principal.FindFirst(System.Security.Claims.ClaimTypes.Email)?.Value;
                var name = principal.FindFirst(System.Security.Claims.ClaimTypes.Name)?.Value;

                Logger.LogInformation("OAuth complete: User authenticated - Email present: {HasEmail}, Name present: {HasName}",
                    !string.IsNullOrEmpty(email), !string.IsNullOrEmpty(name));

                // Store the principal's claims for later use
                _authenticatedPrincipal = principal;
            }
            else
            {
                Logger.LogWarning("OAuth complete: Principal is not authenticated");
            }

            // Log claim types present (without values) for debugging - avoid PII exposure
            if (_authenticatedPrincipal != null)
            {
                var claims = _authenticatedPrincipal.Claims.ToList();
                var claimTypes = claims.Select(c => c.Type).Distinct().ToList();
                Logger.LogInformation("OAuth complete: Principal has {ClaimCount} claims, types present: {ClaimTypes}",
                    claims.Count, string.Join(", ", claimTypes));
            }

            // Attempt to capture returnUrl that may have been stored in AuthenticationProperties.Items during Challenge
            try
            {
                if (authResult.Properties?.Items != null && authResult.Properties.Items.ContainsKey("returnUrl"))
                {
                    _restoredReturnFromProperties = authResult.Properties.Items["returnUrl"];
                    Logger.LogInformation("OAuth complete: Restored returnUrl from auth properties: {Return}", _restoredReturnFromProperties);
                }
            }
            catch (KeyNotFoundException ex)
            {
                Logger.LogWarning(ex, "OAuth complete: KeyNotFoundException reading returnUrl from auth properties");
            }
            catch (NullReferenceException ex)
            {
                Logger.LogWarning(ex, "OAuth complete: NullReferenceException reading returnUrl from auth properties");
            }
            catch (InvalidOperationException ex)
            {
                Logger.LogWarning(ex, "OAuth complete: InvalidOperationException reading returnUrl from auth properties");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "OAuth complete: Unexpected error during authentication");
            _error = "An unexpected error occurred during sign-in. Please try again.";
            _isProcessing = false;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !string.IsNullOrEmpty(_accessToken) && _authenticatedPrincipal != null)
        {
            try
            {
                Logger.LogInformation("OAuth complete: Exchanging OAuth claims for API JWT...");

                // CRITICAL: Extract oid from ClaimsPrincipal first (OpenIdConnect middleware extracts it from id_token)
                // Then fall back to parsing id_token manually if needed
                var email = _authenticatedPrincipal.FindFirst(System.Security.Claims.ClaimTypes.Email)?.Value;
                var name = _authenticatedPrincipal.FindFirst(System.Security.Claims.ClaimTypes.Name)?.Value;

                // CRITICAL: Extract user identifier (oid) from id_token JWT
                // Organizational Azure AD tenant returns real oid (unique Object ID)
                string? userIdentifier = null;

                if (!string.IsNullOrEmpty(_idToken))
                {
                    // Parse id_token to get oid claim
                    userIdentifier = ExtractClaimFromJwt(_idToken, "oid");
                    var subFromToken = ExtractClaimFromJwt(_idToken, "sub");

                    Logger.LogInformation("OAuth complete: id_token claims - oid present: {HasOID}, sub present: {HasSUB}",
                        !string.IsNullOrEmpty(userIdentifier), !string.IsNullOrEmpty(subFromToken));

                    // Fallback to sub if oid is missing
                    if (string.IsNullOrEmpty(userIdentifier))
                    {
                        Logger.LogWarning("OAuth complete: oid claim missing, using sub claim");
                        userIdentifier = subFromToken;
                    }
                }
                else
                {
                    Logger.LogWarning("OAuth complete: id_token is NULL or empty - cannot extract user identifier");
                }

                // Last resort: Use claims from principal
                if (string.IsNullOrEmpty(userIdentifier))
                {
                    userIdentifier = _authenticatedPrincipal.FindFirst("oid")?.Value
                        ?? _authenticatedPrincipal.FindFirst("http://schemas.microsoft.com/identity/claims/objectidentifier")?.Value
                        ?? _authenticatedPrincipal.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;
                    Logger.LogWarning("OAuth complete: Using fallback from principal: identifier present = {HasIdentifier}", !string.IsNullOrEmpty(userIdentifier));
                }

                Logger.LogInformation("OAuth complete: Extracted claims - Email present: {HasEmail}, Name present: {HasName}, UserIdentifier present: {HasUserIdentifier}",
                    !string.IsNullOrEmpty(email), !string.IsNullOrEmpty(name), !string.IsNullOrEmpty(userIdentifier));

                if (string.IsNullOrEmpty(email))
                {
                    Logger.LogError("OAuth complete: No email claim found in principal");
                    _error = "Authentication failed: No email address found.";
                    _isProcessing = false;
                    StateHasChanged();
                    return;
                }

                if (string.IsNullOrEmpty(userIdentifier))
                {
                    Logger.LogError("OAuth complete: No user identifier found in id_token or principal. Available claims: {Claims}",
                        string.Join(", ", _authenticatedPrincipal.Claims.Select(c => c.Type)));
                    _error = "Authentication failed: No user identifier found.";
                    _isProcessing = false;
                    StateHasChanged();
                    return;
                }

                Logger.LogInformation("OAuth complete: Attempting token exchange with claims via /api/auth/exchange...");

                var exchangeRequest = new ClaimsLoginRequest
                {
                    Provider = Provider == "microsoft" ? "AzureAD" : "Google",
                    Email = email,
                    Name = name,
                    ExternalUserId = userIdentifier,  // Use sub for personal MSA, oid for organizational accounts
                    DeviceId = "web-app",
                    DevicePlatform = "Web"
                };

                Logger.LogInformation("Calling API claims exchange endpoint for provider: {Provider}, externalUserId present: {HasExternalUserId}",
                    exchangeRequest.Provider, !string.IsNullOrEmpty(exchangeRequest.ExternalUserId));

                var response = await Http.PostAsJsonAsync("api/auth/exchange", exchangeRequest);

                if (response.IsSuccessStatusCode)
                {
                    var authResponse = await response.Content.ReadFromJsonAsync<AuthenticationResponse>();

                    if (authResponse != null && !string.IsNullOrEmpty(authResponse.AccessToken))
                    {
                        Logger.LogInformation("Token exchange successful! Got our JWT, user email present: {HasEmail}", !string.IsNullOrEmpty(authResponse.User?.Email));

                        // Store OUR JWT (not Microsoft's token)
                        await AuthStateProvider.MarkUserAsAuthenticatedAsync(
                            authResponse.AccessToken,
                            authResponse.RefreshToken,
                            _authenticatedPrincipal);

                        // Determine redirect target.
                        // Prefer the returnUrl that was stored in AuthenticationProperties.Items during the Challenge
                        var restoredReturn = _restoredReturnFromProperties;

                        string chosenSource = "none";
                        string redirectTarget = "/dashboard";

                        if (!string.IsNullOrEmpty(restoredReturn))
                        {
                            // Validate restored return
                            var vr = ReturnUrlValidator.Validate(restoredReturn);
                            if (vr.IsValid)
                            {
                                redirectTarget = vr.Normalized!;
                                chosenSource = "auth-properties";
                            }
                            else
                            {
                                Logger.LogWarning("OAuth complete: Restored returnUrl invalid: {Reason}", vr.ValidationResultCode);
                                restoredReturn = null;
                            }
                        }

                        if (string.IsNullOrEmpty(restoredReturn))
                        {
                            // Fall back to querystring ReturnUrl (already bound to ReturnUrl param) if present
                            if (!string.IsNullOrEmpty(ReturnUrl))
                            {
                                var vr2 = ReturnUrlValidator.Validate(ReturnUrl);
                                if (vr2.IsValid)
                                {
                                    redirectTarget = vr2.Normalized!;
                                    chosenSource = "query-param";
                                }
                                else
                                {
                                    Logger.LogWarning("OAuth complete: Query returnUrl invalid: {Reason}", vr2.ValidationResultCode);
                                    redirectTarget = "/dashboard";
                                    chosenSource = "fallback";
                                }
                            }
                            else
                            {
                                redirectTarget = "/dashboard";
                                chosenSource = "fallback";
                            }
                        }

                                    Logger.LogInformation("OAuth complete: Authentication complete, redirecting to {Target} (source={Source})...", redirectTarget, chosenSource);

                        // CRITICAL: Wait a moment for auth state to propagate to Blazor circuit
                        // Without this, the target page may still see user as unauthenticated
                        await Task.Delay(100);

                        // Use forceLoad=true to ensure the entire page reloads with auth state
                        // This prevents the redirect loop where Dashboard thinks user is not logged in
                        Navigation.NavigateTo(redirectTarget, forceLoad: true);
                    }
                    else
                    {
                        Logger.LogError("Token exchange returned empty response");
                        _error = "Authentication failed: Invalid response from server.";
                        _isProcessing = false;
                        StateHasChanged();
                    }
                }
                else
                {
                    var errorContent = await response.Content.ReadAsStringAsync();
                    Logger.LogError("Token exchange failed: {Status} - {Error}", response.StatusCode, errorContent);
                    _error = $"Authentication failed: {response.StatusCode}";
                    _isProcessing = false;
                    StateHasChanged();
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "OAuth complete: Error completing authentication");
                _error = "An error occurred completing sign-in. Please try again.";
                _isProcessing = false;
                StateHasChanged();
            }
        }
        else if (firstRender && string.IsNullOrEmpty(_accessToken))
        {
            Logger.LogError("OAuth complete: No access token available after first render");
            _error = "Authentication incomplete. Please try again.";
            _isProcessing = false;
            StateHasChanged();
        }
    }

    /// <summary>
    /// Extract a claim value directly from JWT payload without validation.
    /// OIDC middleware has already validated the signature, so we just parse the payload.
    /// This ensures we get the REAL claim values, not middleware-remapped values.
    /// </summary>
    /// <remarks>
    /// JWT format: base64url(header).base64url(payload).base64url(signature)
    /// We only care about the payload to extract claims like 'oid', 'email', etc.
    /// </remarks>
    private string? ExtractClaimFromJwt(string? jwt, string claimName)
    {
        try
        {
            if (string.IsNullOrEmpty(jwt))
            {
                Logger.LogWarning("ExtractClaimFromJwt: JWT is null or empty");
                return null;
            }

            var parts = jwt.Split('.');
            if (parts.Length != 3)
            {
                Logger.LogWarning("ExtractClaimFromJwt: JWT does not have 3 parts");
                return null;
            }

            // Decode JWT payload (add padding if needed for base64 decoding)
            var payload = parts[1];
            var padding = 4 - (payload.Length % 4);
            if (padding != 4)
            {
                payload += new string('=', padding);
            }

            var decodedBytes = Convert.FromBase64String(payload);
            var decoded = System.Text.Encoding.UTF8.GetString(decodedBytes);

            // Parse JSON and extract the requested claim
            using var jsonDoc = System.Text.Json.JsonDocument.Parse(decoded);
            if (jsonDoc.RootElement.TryGetProperty(claimName, out var claimElement))
            {
                var value = claimElement.GetString();
                Logger.LogDebug("ExtractClaimFromJwt: Found claim '{ClaimName}', value present: {HasValue}", claimName, !string.IsNullOrEmpty(value));
                return value;
            }

            Logger.LogWarning("ExtractClaimFromJwt: Claim '{ClaimName}' not found in JWT payload", claimName);
            return null;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "ExtractClaimFromJwt: Failed to extract claim '{ClaimName}' from JWT", claimName);
            return null;
        }
    }
}

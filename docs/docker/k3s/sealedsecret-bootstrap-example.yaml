apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: azure-kv-creds
  namespace: kube-system
spec:
  encryptedData:
    # Use `kubeseal --controller-namespace kube-system -o yaml` to produce the sealed values.
    # The following are placeholders â€” DO NOT commit unencrypted credentials.
    tenantId: AgB...SEALED_BASE64...
    clientId: AgC...SEALED_BASE64...
    clientSecret: AgD...SEALED_BASE64...
  template:
    type: Opaque
    metadata:
      name: azure-kv-creds
      namespace: kube-system

# How to create and use this SealedSecret (high-level):
# 1. Create an Azure service principal and grant it `get` permission on your Key Vault secrets (see docs below).
# 2. Create a Kubernetes Secret YAML (unsealed) with keys tenantId, clientId, clientSecret in namespace kube-system.
# 3. Seal it with kubeseal against your cluster's SealedSecrets controller public key:
#    kubectl create -n kube-system secret generic azure-kv-creds --from-literal=tenantId=<TENANT_ID> \
#      --from-literal=clientId=<CLIENT_ID> --from-literal=clientSecret=<CLIENT_SECRET> --dry-run=client -o yaml \
#      | kubeseal --controller-namespace kube-system --format yaml > sealedsecret-bootstrap.yaml
# 4. Commit `sealedsecret-bootstrap.yaml` to your GitOps repo and apply it to the cluster. The SealedSecrets controller will create the real Secret in the cluster.
